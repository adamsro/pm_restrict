<?php

/**
 * @file
 * Allows sending restrictions on users/roles/groups
 */

/**
 * Allow a user to choose which recipients to send to within the restricted subset.
 */
define('PM_RESTRICT_MULTIPLE_SELECTIONS', 0);

/**
 *  Force a user to send to all recip he/she has been restriced to.
 */
define('PM_RESTRICT_ALL_RECIPIENTS', 1);

/**
 * Implements hook_help().
 */
function pm_restrict_help($path) {
  switch ($path) {
    case 'admin/help#pm_restrict':
      return '<p>' . t('This area is used to define user blocking rules for the Privatemsg module. Rules allow control of who may block messages from whom. By default all users are allowed to block messages from anyone else. However, a site may have groups of users that need to contact or get information to others, for example: the site may have administrative staff or be a forum with moderators. Groups of users are defined by roles, which can be managed on the <a href="@roles">roles configuration page</a>.', array('@roles' => url('admin/user/roles'))) . '</p>';
  }
}

/**
 * Implements hook_menu().
 */
function pm_restrict_menu() {
  $items['admin/config/messaging/privatemsg/restrict'] = array(
    'title'            => 'User restriction rules',
    'description'      => 'Configure rules for which users/groups/roles are restricted to sending to which users/groups/roles.',
    'page callback'    => 'drupal_get_form',
    'page arguments'   => array('pm_restrict_settings'),
    'file'             => 'pm_restrict.admin.inc',
    'access arguments' => array('administer privatemsg settings'),
    'type'             => MENU_LOCAL_TASK,
  );
  $items['messages/restrict/js'] = array(
    'title'            => 'Javascript restrict actions form',
    'page callback'    => 'pm_restrict_js',
    'file'             => 'pm_restrict.admin.inc',
    'access arguments' => array('administer privatemsg settings'),
    'type'             => MENU_CALLBACK,
  );
  // Auto-completes available user names & removes duplicates.
  $items['messages/restrict/autocomplete'] = array(
    'page callback'    => 'pm_restrict_autocomplete',
    'file'             => 'pm_restrict.admin.inc',
    'access arguments' => array('administer privatemsg settings'),
    'type'             => MENU_CALLBACK,
  );
  return $items;
}

/**
 * Implements hook_theme().
 */
function pm_restrict_theme() {
  return array(
    'pm_restrict_actions' => array(
      'render element' => 'form',
      'file'      => 'pm_restrict.admin.inc',
    ),
  );
}

/**
 * Theme the user actions form in the admin area.
 *
 * @ingroup theming
 */
function theme_pm_restrict_actions($form) {
  $rows = array();
  $headers = array(
    t('author'),
    t('may only send to'),
    t('if multiple recipients exist:'),
    t('Enabled'),
    t('Weight'),
    '',
  );
  $form_data = element_children($form['form']);

    $output = '<ul><li>' . t("If multiple restriction rules apply to an author then the last rule applied will take precedence.") . '</li><li>' .
     t("Since all users have the role 'authenticated user', the 'authenticated user' role will be repurposed. The 'authenticated user' role will act to select the set of users who have no other roles aside from 'authenticated user'.") . '</li></ul>';

   // this function is what brings in the javascript to make our table drag-and-droppable
  drupal_add_tabledrag('pm_restrict_table', 'order', 'sibling', 'restrict-weight');

  foreach ($form_data as $key) {
    // Build the table row.
    $row = array(
      'data' => array(
        array('data' => drupal_render($form['form'][$key]['author'])),
        array('data' => drupal_render($form['form'][$key]['recipient'])),
        array('data' => drupal_render($form['form'][$key]['action'])),
        array('data' => drupal_render($form['form'][$key]['enabled'])),
        array('data' => drupal_render($form['form'][$key]['weight'])),
        array('data' => drupal_render($form['form'][$key]['remove'])),
      ),
      'class' => array('draggable', 'tabledrag-leaf'),
    );

    // Add additional attributes to the row, such as a class for this row.
    if (isset($form['form'][$key]['#attributes'])) {
      $row = array_merge($row, $form['form'][$key]['#attributes']);
    }
    $rows[] = $row;
  }

  // If there are no rows, output some instructions for the user.
  if (empty($form_data)) {
    $rows[] = array(
      array(
        'data' => t("No rules have been added. All users may send messages to other users on the system without restriction. To restrict the possible recipients fr a certain role, click 'Add new rule'."),
        'colspan' => '5',
      ),
    );
  }

  $output .= theme('table', array(
    'header' => $headers,
    'rows' => $rows,
    'attributes' => array('id' => 'pm_restrict_table')
  ));

  $output .= drupal_render_children($form['form']);

  return $output;
}

/**
* Change the 'to' field for the privatemsg form for sending a new msg.
*/
function pm_restrict_form_alter(&$form, &$form_state, $form_id) {
  global $user;
  if ($form_id == 'privatemsg_new') {
    list($last_recipient_set, $last_action) = _pm_restrict_get_last_rule($user);
    if(!empty($last_action) && $last_action['action'] == 1) {
      $form['recipient'] = array(
        '#type' => 'textfield',
        '#title' => t('To'),
        '#value' => $last_action['recipient'],
        '#disabled' => TRUE,
        '#weight' => -10,
        '#size' => 50,
        // Disable #maxlength, make it configurable by number of recipients, not
        // their name length.
        '#after_build'        => array('privatemsg_disable_maxlength'),
        );
       // $form['#validate'][] = 'pm_restrict_privatemsg_new_validate';
    }
  }
}

function pm_restrict_privatemsg_new_validate($form, &$form_state) {
}
/**
* Implements hook_privatemsg_block_message().
*/
function pm_restrict_privatemsg_block_message($author, $recipients, $context = array()) {
  $blocked = array();
  if ($author->uid != 1) {
    list($last_recipient_set, $last_action) = _pm_restrict_get_last_rule($author);
    if (!empty($last_recipient_set)) {
      foreach ($recipients as $recipient_id => $recipient) {
        if (!_pm_restrict_user_is_subset_of($recipient, $last_recipient_set)) {
          $blocked[] = array(
            'recipient' => $recipient_id,
            'message' => t('You are not permitted to send messages to !user.', array('!user' => privatemsg_recipient_format($recipient))),
            );
        }
      }
    }
  }
  return $blocked;
}

/**
* Implements hook_query_TAG_alter().
*
* Include conditionals to limit query to whitelisted users.
*/
function pm_restrict_query_privatemsg_autocomplete_alter($query) {
  global $user;
  if ($user->uid != 1) {
    list($last_recipient_set, $last_action) = _pm_restrict_get_last_rule($user);
    if (!empty($last_recipient_set)) {
      // Only restrict to the last rule author is subject to.
      $uids = $rids = $gids = array();
      foreach ($last_recipient_set as $set) {
        if ($set->type == 'user') {
          $uids[] = $set->uid;
        }
        elseif ($set->type == 'role') {
          if ($set->rid == DRUPAL_AUTHENTICATED_RID) {
            $only_authenticated  = TRUE;
          }
          else {
            $rids[] = $set->rid;
          }
        }
        elseif (strpos($set->type, 'og:') !== FALSE) {
          $gids[] = $set->vid;
        }
      }

      $where = db_or();
      // If there are any, limit any listed users.
      if (!empty($uids)) {
        $where->condition('u.uid', $uids, 'IN');
      }
      // If there are any, limit users in restricted roles.
      if (!empty($rids) || $only_authenticated) {
        $join_alias = $query->leftJoin('users_roles', 'ur', 'u.uid = ur.uid');
        if (!empty($rids)) {
          $where->condition($join_alias . '.rid', $rids, 'IN');
        }
        if ($only_authenticated) {
          $where->isNull($join_alias . '.rid');
        }
      }
      // If there are any, limit users in restricted groups.
      if (!empty($gids)) {
        $join_alias = $query->leftJoin('og_membership', 'ogm', 'u.uid = ogm.etid');
        $where->condition($join_alias . '.gid', $gids, 'IN');
      }
      $query->condition($where);
    }
  }
}

/**
* Implements hook_query_TAG_alter().
*
* Include conditionals to limit query to whitelisted roles.
*/
function pm_restrict_query_privatemsg_roles_autocomplete_roles_alter($query) {
  global $user;
  if ($user->uid != 1) {
    list($last_recipient_set, $last_action) = _pm_restrict_get_last_rule($user);
    if (!empty($last_recipient_set)) {
      $rids = array();
      foreach ($last_recipient_set as $set) {
        if ($set->type == 'role') {
          $rids[] = $set->rid;
        }
      }
      if (empty($rids)) {
        $query->isNull('role.rid');
      }
      else {
        $query->condition(db_or()->condition('role.rid', $rids, 'IN'));
      }
    }
  }
}

/**
* Implements hook_privatemsg_autocomplete_alter().
*
* Remove restricted groups from the autocomplete list.
*/
function pm_restrict_privatemsg_autocomplete_alter(&$matches, $names, $fragment) {
  global $user;
  if(module_exists('privatemsg_groups')) {
     list($last_recipient_set, $last_action) = _pm_restrict_get_last_rule($user);
    foreach ($matches as $key => $match) {
      if (strpos($match->type, 'og:') !== FALSE && !_pm_resrict_group_is_in_set($match, $last_recipient_set)) {
        unset($matches[$key]);
      }
    }
  }

}

/**
 * Get the list of allowed recipients for a given author.
 * @param  [type] $account [description]
 * @return array
 *   result form _privatemsg_parse_userstring or empty array
 */
function _pm_restrict_get_last_rule($account) {
  $return = $last_recipient_set = $last_action = array();
  $restrict_actions = variable_get('pm_restrict_actions', array());
  foreach ($restrict_actions as $action) {
    if (!$action['enabled']) {
      continue;
    }
    $action_authors = _privatemsg_parse_userstring($action['author']);
    if (_pm_restrict_user_is_subset_of($account, $action_authors[0])) {
      $last_recipient_set = $action['recipient'];
      $last_action = $action;
    }
  }
    // Only restrict to the last rule author is subject to.
  if (!empty($last_recipient_set)) {
    $last_recipient_set = _privatemsg_parse_userstring($last_recipient_set);
    $last_recipient_set = $last_recipient_set[0];
  }
  return array($last_recipient_set, $last_action);
}

/**
 * Determine if a user is a part of a role or group
 *  using 'load_recipients' would be more portable but less efficient
 *
 * @param  $user
 *  Drupal account object
 * @param  $set
 *   array result of _privatemsg_parse_userstring
 * @return
 *   TRUE if user is a member of the given set.
 */
function _pm_restrict_user_is_subset_of($item, $set) {
  foreach ($set as $object) {
    if (isset($item->uid)) {
      // Item is a user account and may be a match to iteself or a subset of a role/group
      if ($object->type == 'user' && $item->uid == $object->uid) {
        return TRUE;
      }
      elseif ($object->type == 'role' && $object->rid == DRUPAL_AUTHENTICATED_RID) {
        // All users are 'authenticated users' even though this relationship is not explicitly stored in the database.
        // Special behavior for 'authenticated user' role.
        // If 'set' is role 'authenticated user' only return true if item has no other roles.
        if (count($item->roles) == 1) {
          return TRUE;
        }
      }
      elseif ($object->type == 'role' && isset($item->roles[$object->rid])) {
        return TRUE;
      }
      elseif (strpos($object->type, 'og:') !== FALSE) {
        if (function_exists('og_is_member')
          && og_is_member(str_replace('og:', '', $object->type), $object->vid, 'user', $item) == TRUE) {
          return TRUE;
      }
    }
  }
  elseif ($item->type = 'role' && $object->type == 'role' && $item->rid == $object->rid) {
  // Item is a role and may only be a subset of iteself.
   return TRUE;
  }
  elseif (strpos($item->type, 'og:') !== FALSE && strpos($object->type, 'og:') !== FALSE && $item->vid == $object->vid) {
  // Item is a group and may only be a subset of iteself.
   return TRUE;

  }
}
return FALSE;
}

/**
 * Determine if a group is in an array of results.
 * @param  object $group
 *  object describing an organic group
 * @param  array $set
 *  mixed set may contain users, roles, and groups
 * @return bool
 *  TRUE if group is an element in $set
 */
function _pm_resrict_group_is_in_set($group, $set) {
  foreach ($set as $s) {
    if ($group->vid == $s->vid) {
      return TRUE;
    }
  }
  return FALSE;
}

