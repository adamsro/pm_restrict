<?php

/**
 * @file
 * Allows sending restrictions on users/roles/groups
 */

/**
 * Allow a user to choose which recipients to send to within the restricted subset.
 */
define('PM_RESTRICT_MULTIPLE_SELECTIONS', 0);

/**
 *  Force a user to send to all recip he/she has been restriced to.
 */
define('PM_RESTRICT_ALL_RECIPIENTS', 1);

/**
 * Implements hook_help().
 */
function pm_restrict_help($path) {
  switch ($path) {
    case 'admin/help#pm_restrict':
      return '<p>' . t('This area is used to define user blocking rules for the Privatemsg module. Rules allow control of who may block messages from whom. By default all users are allowed to block messages from anyone else. However, a site may have groups of users that need to contact or get information to others, for example: the site may have administrative staff or be a forum with moderators. Groups of users are defined by roles, which can be managed on the <a href="@roles">roles configuration page</a>.', array('@roles' => url('admin/user/roles'))) . '</p>';
  }
}

/**
 * Implements hook_menu().
 */
function pm_restrict_menu() {
  $items['admin/config/messaging/privatemsg/restrict'] = array(
    'title'            => 'User restriction rules',
    'description'      => 'Configure rules for which users/groups/roles are restricted to sending to which users/groups/roles.',
    'page callback'    => 'drupal_get_form',
    'page arguments'   => array('pm_restrict_settings'),
    'file'             => 'pm_restrict.admin.inc',
    'access arguments' => array('administer privatemsg settings'),
    'type'             => MENU_LOCAL_TASK,
  );
  $items['messages/restrict/js'] = array(
    'title'            => 'Javascript block actions form',
    'page callback'    => 'pm_restrict_js',
    'file'             => 'pm_restrict.admin.inc',
    'access arguments' => array('administer privatemsg settings'),
    'type'             => MENU_CALLBACK,
  );
  return $items;
}

/**
 * Implements hook_theme().
 */
function pm_restrict_theme() {
  return array(
    'pm_restrict_actions' => array(
      'render element' => 'form',
      'file'      => 'pm_restrict.admin.inc',
    ),
  );
}

/**
 * Theme the user actions form.
 *
 * @ingroup theming
 */
function theme_pm_restrict_actions($form) {
  $rows = array();
  $headers = array(
    t('author'),
    t('may only send to'),
    t('if multiple recipients exist:'),
    t('Enabled'),
    t('Weight'),
    '',
  );
  $form_data = element_children($form['form']);

    $output = '<ul><li>' . t("If multiple restriction rules apply to an author. The last rule applied will take precedence.") . '</li><li>' .
     t("Since all users have the role 'authenticated user', the 'authenticated user' role will be repurposed. The 'authenticated user' role will act to select the set of users who have no other roles aside from 'authenticated user'.") . '</li></ul>';

   // this function is what brings in the javascript to make our table drag-and-droppable
  drupal_add_tabledrag('pm_restrict_table', 'order', 'sibling', 'restrict-weight');

  foreach ($form_data as $key) {
    // Build the table row.
    $row = array(
      'data' => array(
        array('data' => drupal_render($form['form'][$key]['author'])),
        array('data' => drupal_render($form['form'][$key]['recipient'])),
        array('data' => drupal_render($form['form'][$key]['action'])),
        array('data' => drupal_render($form['form'][$key]['enabled'])),
        array('data' => drupal_render($form['form'][$key]['weight'])),
        array('data' => drupal_render($form['form'][$key]['remove'])),
      ),
      'class' => array('draggable', 'tabledrag-leaf'),
    );

    // Add additional attributes to the row, such as a class for this row.
    if (isset($form['form'][$key]['#attributes'])) {
      $row = array_merge($row, $form['form'][$key]['#attributes']);
    }
    $rows[] = $row;
  }

  // If there are no rows, output some instructions for the user.
  if (empty($form_data)) {
    $rows[] = array(
      array(
        'data' => t("No rules have been added. All users may send messages to other users on the system without restriction. To restrict the possible recipients fr a certain role, click 'Add new rule'."),
        'colspan' => '5',
      ),
    );
  }

  $output .= theme('table', array(
    'header' => $headers,
    'rows' => $rows,
    'attributes' => array('id' => 'pm_restrict_table')
  ));

  $output .= drupal_render_children($form['form']);

  return $output;
}

/**
 * Determine if a user is a part of a role or group
 *  using 'load_recipients' would be more portable but less efficient
 *
 * @param  $user
 *  Drupal account object
 * @param  $set
 *   array result of _privatemsg_parse_userstring
 * @return
 *   TRUE if user is a member of the given set.
 */
function _pm_restrict_is_subset_of($account, $set) {
  foreach ($set as $object) {
    if ($object->type == 'user' && $account->uid == $object->uid) {
      return TRUE;
    }
    elseif ($object->type == 'role' && $object->rid == DRUPAL_AUTHENTICATED_RID && count($account->roles) == 0) {
      // All users are 'authenticated users' even though this relationship is not explicitly stored in the database.
      // Special behavior for 'authenticated user' role.
      // If 'set' is role 'authenticated user' only return true if account has no other roles.
      return TRUE;
    }
    elseif ($object->type == 'role' && isset($account->roles[$object->rid])) {
      return TRUE;
    }
    elseif (strpos($object->type, 'og:') !== FALSE) {
      if (function_exists('og_is_member')
        && og_is_member(str_replace('og:', '', $object->type), $object->vid, 'user', $account) == TRUE) {
        return TRUE;
      }
    }
  }
  return FALSE;
}

/**
 * Implements hook_privatemsg_block_message().
 */
function pm_restrict_privatemsg_block_message($author, $recipients, $context = array()) {
  if ($user->uid == 1) {
    return array();
  }
  $last_recipient_set = _pm_restrict_get_last_rule($author);
  if (empty($last_recipient_set)) {
    return array();
  }
  $blocked = array();
  foreach ($recipients as $recipient_id => $recipient) {
    if (!_pm_restrict_is_subset_of($recipient, $last_recipient_set[0])) {
      $blocked[] = array(
        'recipient' => $recipient_id,
        'message' => t('You are not permitted to send messages to !user.', array('!user' => privatemsg_recipient_format($recipient))),
        );
    }
  }
  return $blocked;
}

/**
 * Get the list of allowed recipients for a given author.
 * @param  [type] $account [description]
 * @return array
 *   result form _privatemsg_parse_userstring or empty array
 */
function _pm_restrict_get_last_rule($account) {
  $last_recipient_set = array();
  $restrict_actions = variable_get('pm_restrict_actions', array());
  foreach ($restrict_actions as $action) {
    if (!$action['enabled']) {
      continue;
    }
    $action_authors = _privatemsg_parse_userstring($action['author']);
    if (_pm_restrict_is_subset_of($account, $action_authors[0])) {
      $last_recipient_set = $action['recipient'];
    }
  }
    // Only restrict to the last rule author is subject to.
  if (!empty($last_recipient_set)) {
    $last_recipient_set = _privatemsg_parse_userstring($last_recipient_set);
  }
  return $last_recipient_set;
}

/**
* Implements hook_query_TAG_alter().
*
* Include conditionals to limit query to whitelisted users.
*/
function pm_restrict_query_privatemsg_autocomplete_alter($query) {
  global $user;
  if ($user->uid != 1) {
    $last_recipient_set = _pm_restrict_get_last_rule($user);
    if (!empty($last_recipient_set)) {
      // Only restrict to the last rule author is subject to.
      $uids = $rids = $gids = array();
      foreach ($last_recipient_set[0] as $set) {
        if ($set->type == 'user') {
          $uids[] = $set->uid;
        }
        elseif ($set->type == 'role') {
          if ($set->rid === DRUPAL_AUTHENTICATED_RID) {
            $only_authenticated  = TRUE;
          }
          else {
            $rids[] = $set->rid;
          }
        }
        elseif (strpos($set->type, 'og:') !== FALSE) {
          $gids[] = $set->vid;
        }
      }
      $where = db_or();
      // If there are any, limit any listed users.
      if (!empty($uids)) {
        $where->condition('u.uid', $uids, 'IN');
      }
      // If there are any, limit users in restricted roles.
      if (!empty($rids)) {
        $join_alias = $query->leftJoin('users_roles', 'ur', 'u.uid = ur.uid');
        $where->condition($join_alias . '.rid', $rids, 'IN');
        if ($only_authenticated) {
          $where->isNull($join_alias . '.rid');
        }
      }
      // If there are any, limit users in restricted groups.
      if (!empty($gids)) {
        $join_alias = $query->leftJoin('og_membership', 'ogm', 'u.uid = ogm.etid');
        $where->condition($join_alias . '.gid', $gids, 'IN');
      }
      $query->condition($where);
    }
  }
}

/**
* Implements hook_query_TAG_alter().
*
* Include conditionals to limit query to whitelisted roles.
*/
function pm_restrict_query_privatemsg_roles_autocomplete_roles_alter($query) {
  global $user;
  if ($user->uid != 1) {
    $last_recipient_set = _pm_restrict_get_last_rule($user);
    if (!empty($last_recipient_set)) {
      foreach ($last_recipient_set[0] as $set) {
        if ($set->type == 'role') {
          $rids[] = $set->rid;
        }
      }
      if (!empty($rids)) {
        $query->condition(db_or()->condition('role.rid', $rids, 'IN'));
      }
    }
  }
}

